<style>


  .inkpad-toolbar:not(.open){ display:none !important; }
  .inkpad-toolbar.open{ display:flex; }

  /* Ensure toolbar always clickable (and fast on touch) */
  .inkpad-toolbar{ pointer-events:auto; }
  .inkpad-btn{ touch-action:manipulation; user-select:none; }

  /* Nice visual cue when drawing */
  #inkpad-canvas.drawing { cursor: crosshair !important; }
  #quarto-content > #inkpad-canvas { padding-top: 0 !important; }

/* And make sure the canvas itself never has padding/margins */
  #inkpad-canvas { padding: 0 !important; margin: 0; display: block; box-sizing: content-box; }

  /* Floating toolbar */
  .inkpad-toolbar {
    position: fixed; z-index: 9999; right: 10px; bottom: 10px;
    gap: 4px; background: transparent;
    padding: 2px; border-radius: 8px;
  }
  .inkpad-btn {
    border: 0; border-radius: 10px; padding: 8px 10px; color: var(--brand-fg); cursor: pointer;
    background: var(--surface); font: 600 12px/1.1;
  }
  .inkpad-btn.active { background: var(--brand-teal); color: var(--brand-bg) }
  .inkpad-hint {
    position: fixed; right: 16px; bottom: 72px; color: var(--brand-fg); font: 12px;
    background: var(--surface); padding: 8px 8px; border-radius: 5px; display: none;
  }
  /* Canvas overlay (document-sized, scrolls with page) */
  #inkpad-canvas {
    position: fixed; top: 0; left: 0;
    z-index: 9998;
    touch-action: none;
    /* width/height are set by JS; no padding/margins ever */
    padding: 0 !important; margin: 0; display: block; box-sizing: content-box;
  }

/* ----- Popover ----- */
.inkpad-popover {
  position: fixed;
  right: 10px;
  bottom: 56px;                /* sits just above the toolbar */
  z-index: 10000;
  display: none;
  padding: 10px;
  background: var(--surface);
  color: var(--brand-fg);
  border-radius: 12px;
  box-shadow: 0 10px 30px rgba(0,0,0,.22);
  width: 240px;
}

/* little arrow pointing to the toolbar */
.inkpad-popover::after {
  content: "";
  position: absolute;
  right: 18px;
  bottom: -8px;
  width: 14px; height: 14px;
  background: var(--surface);
  transform: rotate(45deg);
  box-shadow: 3px 3px 10px rgba(0,0,0,.12);
}

.inkpad-popover.open { display: block; }

.inkpad-field {
  display: flex;
  flex-direction: column;
  gap: 6px;
  margin-bottom: 10px;
}
.inkpad-field:last-child { margin-bottom: 0; }

.inkpad-field label {
  font: 600 12px/1.2 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
  color: var(--brand-fg);
}
.inkpad-out {
  font-weight: 700;
  color: var(--brand-teal);
}

/* ----- Color input (tidy circular swatch) ----- */
#inkpad-color {
  appearance: none;
  -webkit-appearance: none;
  width: 32px;
  height: 32px;
  border-radius: 50%;
  padding: 0;
  border: 2px solid rgba(0,0,0,.15);
  background: transparent;
  cursor: pointer;
  overflow: hidden;
}
#inkpad-color::-webkit-color-swatch-wrapper { padding: 0; }
#inkpad-color::-webkit-color-swatch {
  border: none;
  border-radius: 50%;
}
#inkpad-color::-moz-color-swatch {
  border: none;
  border-radius: 50%;
}

/* ----- Range sliders (brand-styled, accessible) ----- */
#inkpad-size,
#inkpad-eraser-size {
  width: 100%;
  height: 28px;                 /* easier to grab on touch */
  background: transparent;
  cursor: pointer;
}

/* WebKit */
#inkpad-size::-webkit-slider-runnable-track,
#inkpad-eraser-size::-webkit-slider-runnable-track {
  height: 6px;
  background: linear-gradient(90deg, var(--brand-teal), var(--brand-teal)) 0/var(--_fill,0%) 100% no-repeat,
              color-mix(in oklab, var(--brand-fg) 10%, transparent);
  border-radius: 999px;
}
#inkpad-size::-webkit-slider-thumb,
#inkpad-eraser-size::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 18px; height: 18px;
  border-radius: 50%;
  background: var(--brand-bg);
  border: 2px solid var(--brand-teal);
  margin-top: -6px;            /* centers thumb on 6px track */
}

/* Firefox */
#inkpad-size::-moz-range-track,
#inkpad-eraser-size::-moz-range-track {
  height: 6px;
  background: color-mix(in oklab, var(--brand-fg) 10%, transparent);
  border-radius: 999px;
}
#inkpad-size::-moz-range-progress,
#inkpad-eraser-size::-moz-range-progress {
  height: 6px;
  background: var(--brand-teal);
  border-radius: 999px;
}
#inkpad-size::-moz-range-thumb,
#inkpad-eraser-size::-moz-range-thumb {
  width: 18px; height: 18px;
  border-radius: 50%;
  background: var(--brand-bg);
  border: 2px solid var(--brand-teal);
}

/* Improve focus ring for a11y */
#inkpad-color:focus-visible,
#inkpad-size:focus-visible,
#inkpad-eraser-size:focus-visible,
#inkpad-options:focus-visible {
  outline: 2px solid var(--brand-teal);
  outline-offset: 2px;
}

/* Mobile: turn the popover into a bottom sheet */
@media (max-width: 560px) {
  .inkpad-popover {
    right: 10px; left: 10px;
    bottom: 60px;
    width: auto;
  }
  .inkpad-popover::after { right: 24px; }
}

.inkpad-btn .inkpad-icon { width: 16px; height: 16px; display: block; }
.inkpad-btn.active .inkpad-icon { transform: rotate(30deg); transition: transform .15s ease; }


</style>

<div class="inkpad-toolbar" id="inkpad-toolbar" aria-label="Ink toolbar" aria-hidden="true">
  <button class="inkpad-btn" id="inkpad-toggle" type="button" aria-pressed="false" title="Toggle ink (D)">‚úçÔ∏è Draw</button>
  <button class="inkpad-btn active" id="inkpad-pen"    type="button" title="Pen (P)">Pen</button>
  <button class="inkpad-btn"         id="inkpad-eraser" type="button" title="Eraser (E)">Eraser</button>
  <button class="inkpad-btn"         id="inkpad-undo"   type="button" title="Undo (Z)">Undo</button>
  <button class="inkpad-btn"         id="inkpad-clear"  type="button" title="Clear">Clear</button>
  <button class="inkpad-btn"         id="inkpad-save"   type="button" title="Save PNG">Save</button>
  <button class="inkpad-btn" id="inkpad-options" type="button" title="Pen/Eraser options" aria-expanded="false">
    <svg class="inkpad-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor"
        stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
        <!-- Feather "settings" glyph -->
        <circle cx="12" cy="12" r="3"></circle>
        <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 1 1-2.83 2.83l-.06-.06a1.65 1.65 0 0 0-1.82-.33
                1.65 1.65 0 0 0-1 1.51V21a2 2 0 1 1-4 0v-.09a1.65 1.65 0 0 0-1-1.51
                1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 1 1-2.83-2.83l.06-.06
                a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 1 1 0-4h.09
                a1.65 1.65 0 0 0 1.51-1 1.65 1.65 0 0 0-.33-1.82l-.06-.06
                a2 2 0 1 1 2.83-2.83l.06.06a1.65 1.65 0 0 0 1.82.33H9
                A1.65 1.65 0 0 0 10 3.09V3a2 2 0 1 1 4 0v.09
                a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06
                a2 2 0 1 1 2.83 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9
                c0 .66.39 1.27 1 1.51.16.06.33.09.51.09H21a2 2 0 1 1 0 4h-.09
                a1.65 1.65 0 0 0-1.51 1z"/>
    </svg>
  </button>
</div>


<!-- Popover container -->
<div id="inkpad-popover" class="inkpad-popover" aria-hidden="true">
  <div class="inkpad-field">
    <label for="inkpad-color">Pen colour</label>
    <input id="inkpad-color" type="color" value="#ff0055" />
  </div>

  <div class="inkpad-field">
    <label for="inkpad-size">
      Pen size <span class="inkpad-out" id="inkpad-size-out">3</span>px
    </label>
    <input id="inkpad-size" type="range" min="1" max="20" step="0.5" value="3" />
  </div>

  <div class="inkpad-field">
    <label for="inkpad-eraser-size">
      Eraser size <span class="inkpad-out" id="inkpad-eraser-size-out">12</span>px
    </label>
    <input id="inkpad-eraser-size" type="range" min="5" max="50" step="1" value="12" />
  </div>
</div>

<!-- <div class="inkpad-hint" id="inkpad-hint">Ink ON ‚Äî use pen (Shift+mouse on laptop)</div> -->
<canvas id="inkpad-canvas" aria-hidden="true"></canvas>

<script>
(() => {
  const canvas = document.getElementById('inkpad-canvas');
  const tb = (id) => document.getElementById(id);
  const toolbar = document.getElementById('inkpad-toolbar');
  const key = 'ink:' + location.pathname; // per-page storage key
  const ctx = canvas.getContext('2d');
  let drawingEnabled = false;
  let tool = 'pen'; // 'pen' | 'eraser'
  let penColor   = '#ff0055';
  let penSize    = 3;
  let eraserSize = 12;  // in CSS px
  let strokes = []; // array of {tool, color, size, points:[{x,y,p}]}
  let current = null;
  const baseSize = 3; // base pen size in CSS px

  function onButton(id, fn){
    const el = tb(id);
    if(!el) return;
    el.addEventListener('click', (e)=>{
      e.preventDefault();
      e.stopPropagation();
      fn(e);
    }, {passive:false});
  }

  // Popover toggle + outside close
  const optionsBtn = document.getElementById('inkpad-options');
  const popover    = document.getElementById('inkpad-popover');

  if (optionsBtn && popover) {
    optionsBtn.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        const open = !popover.classList.contains('open');
        popover.classList.toggle('open', open);
        popover.setAttribute('aria-hidden', String(!open));
        optionsBtn.setAttribute('aria-expanded', String(open));
        optionsBtn.classList.toggle('active', open); // optional styling
  }, { passive: false });

  // Close when clicking outside
  document.addEventListener('click', (e) => {
        if (!popover.classList.contains('open')) return;
        if (e.target.closest('#inkpad-popover') || e.target.closest('#inkpad-options')) return;
        popover.classList.remove('open');
        popover.setAttribute('aria-hidden', 'true');
        optionsBtn.setAttribute('aria-expanded', 'false');
        optionsBtn.classList.remove('active');
    }, { capture: true });
  }


  const colorInput  = document.getElementById('inkpad-color');
  const sizeInput   = document.getElementById('inkpad-size');
  const eraserInput = document.getElementById('inkpad-eraser-size');

  if (colorInput) {
    colorInput.addEventListener('input', e => { penColor = e.target.value; });
  }
  if (sizeInput) {
    sizeInput.addEventListener('input', e => { penSize = +e.target.value; });
  }
  if (eraserInput) {
    eraserInput.addEventListener('input', e => { eraserSize = +e.target.value; });
  }

  // --- slider outputs + track fill ---
  const sizeOut    = document.getElementById('inkpad-size-out');
  const eraserOut  = document.getElementById('inkpad-eraser-size-out');

  function setRangeFill(el) {
    const min = +el.min || 0, max = +el.max || 100, val = +el.value || 0;
    const pct = Math.max(0, Math.min(100, ((val - min) / (max - min)) * 100));
    el.style.setProperty('--_fill', pct + '%');   // used by your CSS gradient
  }

  // initial sync
  if (sizeOut)   sizeOut.textContent   = String(penSize);
  if (eraserOut) eraserOut.textContent = String(eraserSize);
  if (sizeInput)   setRangeFill(sizeInput);
  if (eraserInput) setRangeFill(eraserInput);

  // live updates
  if (sizeInput) {
    sizeInput.addEventListener('input', e => {
        penSize = +e.target.value;
        if (sizeOut) sizeOut.textContent = String(penSize);
        setRangeFill(sizeInput);
    });
  }
  if (eraserInput) {
    eraserInput.addEventListener('input', e => {
        eraserSize = +e.target.value;
        if (eraserOut) eraserOut.textContent = String(eraserSize);
        setRangeFill(eraserInput);
    });
  }

  // Size canvas to the full scrollable document (not just the viewport)
  function docSize() {
    const d = document.documentElement, b = document.body;
    const w = Math.max(d.scrollWidth,  b ? b.scrollWidth  : 0, d.clientWidth);
    const h = Math.max(d.scrollHeight, b ? b.scrollHeight : 0, d.clientHeight);
    return {w: Math.ceil(w), h: Math.ceil(h)};
  }

  function fitCanvas() {
    const dpr = currentDpr();
    const w = window.innerWidth;
    const h = window.innerHeight;

    canvas.width  = Math.ceil(w * dpr);
    canvas.height = Math.ceil(h * dpr);
    canvas.style.width  = w + 'px';
    canvas.style.height = h + 'px';

    // Set transform in redraw().
    scheduleRedraw();
  }

  // Re-measure shortly after load to catch late reflows (math/images)
  setTimeout(fitCanvas, 500);


  // save only serializable fields
  function save(){
    try {
        const lean = strokes.map(({anchorId, tool, color, size, points}) => ({anchorId, tool, color, size, points}));
        localStorage.setItem(key, JSON.stringify(lean));
    } catch {}
  }

  function load(){
    try {
        const s = localStorage.getItem(key);
        strokes = s ? (JSON.parse(s) || []) : [];
        for (const st of strokes) recomputeMeta(st);
    } catch { strokes = []; }
  }

  function redraw(){
    const dpr = currentDpr();
    const sx = window.scrollX, sy = window.scrollY;

    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.setTransform(dpr, 0, 0, dpr, -sx * dpr, -sy * dpr);

    const vx0 = sx, vy0 = sy, vx1 = sx + window.innerWidth, vy1 = sy + window.innerHeight;

    // Cache anchor offsets this frame
    const anchorCache = new Map();
    const infoFor = (id) => {
        if (!anchorCache.has(id)) anchorCache.set(id, anchorInfo(id));
        return anchorCache.get(id);
    };

    for (const s of strokes) {
        const info = infoFor(s.anchorId || 'global');
        if (!info.visible) continue;
        const B = s.localBBox;
        const absBox = { x0: B.x0 + info.left, y0: B.y0 + info.top, x1: B.x1 + info.left, y1: B.y1 + info.top };
        if (intersects(absBox, vx0, vy0, vx1, vy1)) drawStrokeAnchored(s, info);
    }
    if (current) {
        const info = infoFor(current.anchorId || 'global');
        if (info.visible) drawStrokeAnchored(current, info);
    }
    }

  function styleFor(stroke){
    if (stroke.tool === 'eraser') {
        ctx.globalCompositeOperation = 'destination-out';
        ctx.strokeStyle = '#000';
        ctx.lineWidth = stroke.size; // ‚Üê eraserSize already baked in
    } else if (stroke.tool === 'highlight') {
        ctx.globalCompositeOperation = 'multiply';
        ctx.strokeStyle = (stroke.color || '#ff0') + '33';
        ctx.lineWidth = stroke.size * 2;
    } else {
        ctx.globalCompositeOperation = 'source-over';
        ctx.strokeStyle = stroke.color || penColor;
        ctx.lineWidth = stroke.size;
    }
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
  }


  function drawStrokeAnchored(stroke, info){
    ctx.save();
    styleFor(stroke);
    // shift local -> page by current anchor offset
    ctx.translate(info.left, info.top);

    if (stroke._localPath) {
        ctx.stroke(stroke._localPath);       // committed stroke: cheap
    } else {
        // current stroke: build on the fly (local coords)
        const pts = stroke.points || [];
        if (!pts.length) { ctx.restore(); return; }
        if (pts.length === 1) {
        const r = ctx.lineWidth/2;
        ctx.beginPath(); ctx.arc(pts[0].x, pts[0].y, Math.max(1,r), 0, Math.PI*2);
        ctx.fillStyle = (stroke.tool==='eraser') ? '#000' : ctx.strokeStyle;
        ctx.fill();
        } else {
        ctx.beginPath();
        ctx.moveTo(pts[0].x, pts[0].y);
        for (let i=1;i<pts.length-1;i++){
            const c=pts[i], n=pts[i+1];
            ctx.quadraticCurveTo(c.x, c.y, (c.x+n.x)/2, (c.y+n.y)/2);
        }
        const last = pts[pts.length-1];
        ctx.lineTo(last.x, last.y);
        ctx.stroke();
        }
    }
    ctx.restore();
  }

  function setDrawing(enabled){
    drawingEnabled = enabled;
    canvas.style.pointerEvents = enabled ? 'auto' : 'none';
    canvas.classList.toggle('drawing', enabled);
    const drawBtn = tb('inkpad-toggle');
    drawBtn.classList.toggle('active', enabled);
    drawBtn.setAttribute('aria-pressed', String(enabled));
    drawBtn.textContent = enabled ? 'üõë Stop' : '‚úçÔ∏è Draw';
    scheduleRedraw(); // <‚Äî repaint immediately
  }

  function setTool(t){
    tool = t;
    tb('inkpad-pen').classList.toggle('active', t==='pen');
    tb('inkpad-eraser').classList.toggle('active', t==='eraser');
  }

  // performance: cap dpr to avoid excessive sizes on high-dpi screens
  const DPR_CAP = 1.5;                           // tune if you like
  function currentDpr(){ return Math.min(window.devicePixelRatio || 1, DPR_CAP); }

  // Throttle redraws to once per frame
  let raf = 0;
  function scheduleRedraw(){
    if (raf) return;
    raf = requestAnimationFrame(() => { raf = 0; redraw(); });
  }

  function buildPath2DLocal(stroke){
    const pts = stroke.points || [];
    const path = new Path2D();
    if (!pts.length) return path;
    if (pts.length === 1) {
        const size = stroke.size || 3;
        path.arc(pts[0].x, pts[0].y, Math.max(1, size/2), 0, Math.PI*2);
        return path;
    }
    path.moveTo(pts[0].x, pts[0].y);
    for (let i=1; i<pts.length-1; i++){
        const c = pts[i], n = pts[i+1];
        path.quadraticCurveTo(c.x, c.y, (c.x+n.x)/2, (c.y+n.y)/2);
    }
    const last = pts[pts.length-1];
    path.lineTo(last.x, last.y);
    return path;
  }

  function recomputeMeta(s){
    if (!s.points?.length) return;
    // local bbox in anchor space
    let b = {x0:s.points[0].x,y0:s.points[0].y,x1:s.points[0].x,y1:s.points[0].y};
    for (const p of s.points){ if (p.x<b.x0) b.x0=p.x; if (p.y<b.y0) b.y0=p.y; if (p.x>b.x1) b.x1=p.x; if (p.y>b.y1) b.y1=p.y; }
    s.localBBox = b;
    // cache local path (non-serializable)
    Object.defineProperty(s, '_localPath', { value: buildPath2DLocal(s), enumerable: false, writable: true });
  }


  function pushPointDecimated(arr, p, minDist=0.75){ // CSS px
    const last = arr[arr.length-1];
    if (!last) { arr.push(p); return true; }
    const dx = p.x - last.x, dy = p.y - last.y;
    if (dx*dx + dy*dy < minDist*minDist) return false;
    arr.push(p); return true;
  }
  function expandBBox(b, p){
    b.x0 = Math.min(b.x0, p.x); b.y0 = Math.min(b.y0, p.y);
    b.x1 = Math.max(b.x1, p.x); b.y1 = Math.max(b.y1, p.y);
  }
  function newBBox(p){ return {x0:p.x, y0:p.y, x1:p.x, y1:p.y}; }
  function intersects(b, x0,y0,x1,y1){ return !(b.x1 < x0 || b.x0 > x1 || b.y1 < y0 || b.y0 > y1); }


  function getAnchorAtPoint(clientX, clientY) {
    // Temporarily let the page receive the hit
    const prev = canvas.style.pointerEvents;
    canvas.style.pointerEvents = 'none';
    const hit = document.elementFromPoint(clientX, clientY);
    canvas.style.pointerEvents = prev || (drawingEnabled ? 'auto' : 'none');

    const el = hit?.closest('details, .collapse, .callout, [data-ink-surface]');
    if (!el) return { id: 'global', el: null };
    if (!el.id) el.id = 'ink-surface-' + Math.random().toString(36).slice(2,9);
    return { id: el.id, el };
  }


  function anchorInfo(anchorId) {
    if (anchorId === 'global') return { left: 0, top: 0, visible: true };
    const el = document.getElementById(anchorId);
    if (!el) return { left: 0, top: 0, visible: false };

    const cs = getComputedStyle(el);
    const visible = cs.display !== 'none' && cs.visibility !== 'hidden';
    const expanded =
        (el.tagName.toLowerCase() !== 'details' || el.open) &&
        (!el.classList.contains('collapse') || el.classList.contains('show'));
    if (!visible || !expanded) return { left: 0, top: 0, visible: false };

    const r = el.getBoundingClientRect();
    return { left: r.left + window.scrollX, top: r.top + window.scrollY, visible: true };
  }

    // pointer in LOCAL anchor coords
  function pointerPosLocal(e, anchorEl) {
    if (!anchorEl) return { x: e.pageX, y: e.pageY, p: e.pressure>0?e.pressure:0.5 };
    const r = anchorEl.getBoundingClientRect();
    return { x: e.clientX - r.left, y: e.clientY - r.top, p: e.pressure>0?e.pressure:0.5 };
  }



  function pointerPos(e){  // page space (CSS px)
    return { x: e.pageX, y: e.pageY, p: (e.pressure>0 ? e.pressure : 0.5) };
  }


  let currentAnchor = { id: 'global', el: null };

  canvas.addEventListener('pointerdown', (e)=>{
    if (!drawingEnabled) return;
    try { canvas.setPointerCapture?.(e.pointerId); } catch {}
    currentAnchor = getAnchorAtPoint(e.clientX, e.clientY);

    const p = pointerPosLocal(e, currentAnchor.el);
    current = {
        anchorId: currentAnchor.id,
        tool,
        color: penColor,
        size: tool === 'eraser' ? eraserSize : penSize,
        points: [p],
        localBBox: {x0:p.x,y0:p.y,x1:p.x,y1:p.y}
    };
    e.preventDefault();
    scheduleRedraw();
  }, {passive:false});

  canvas.addEventListener('pointermove', (e)=>{
    if (!current) return;
    const p = pointerPosLocal(e, currentAnchor.el);
    if (pushPointDecimated(current.points, p)) {
        current.localBBox.x0 = Math.min(current.localBBox.x0, p.x);
        current.localBBox.y0 = Math.min(current.localBBox.y0, p.y);
        current.localBBox.x1 = Math.max(current.localBBox.x1, p.x);
        current.localBBox.y1 = Math.max(current.localBBox.y1, p.y);
    }
    e.preventDefault();
    scheduleRedraw();
  }, {passive:false});

  function endStroke(e){
    if (!current) return;
    const p = pointerPosLocal(e, currentAnchor.el);
    if (pushPointDecimated(current.points, p)) {
        current.localBBox.x0 = Math.min(current.localBBox.x0, p.x);
        current.localBBox.y0 = Math.min(current.localBBox.y0, p.y);
        current.localBBox.x1 = Math.max(current.localBBox.x1, p.x);
        current.localBBox.y1 = Math.max(current.localBBox.y1, p.y);
    }
    recomputeMeta(current);                      // builds _localPath
    strokes.push(current);
    current = null;
    try { canvas.releasePointerCapture?.(e.pointerId); } catch {}
    save();
    scheduleRedraw();
  }


  canvas.addEventListener('pointerup', endStroke);
  canvas.addEventListener('pointercancel', endStroke);
  canvas.addEventListener('pointerleave', endStroke);

  // --- hook up the toolbar buttons so clicks always ‚Äúregister‚Äù ---
  onButton('inkpad-toggle', () => setDrawing(!drawingEnabled));
  onButton('inkpad-pen',    () => setTool('pen'));
  onButton('inkpad-eraser', () => setTool('eraser'));
  onButton('inkpad-undo',   () => { strokes.pop(); save(); redraw(); });
  onButton('inkpad-clear',  () => {
    if (confirm('Clear all ink on this page?')) { strokes = []; save(); redraw(); }
  });
  onButton('inkpad-save',   () => {
    const url = canvas.toDataURL('image/png');
    const a = document.createElement('a');
    a.download = (document.title || 'notes') + '.png';
    a.href = url; a.click();
  });

  // Keyboard shortcuts
  document.addEventListener('keydown', (e) => {
    // Only when toolbar is visible
    if (!toolbar.classList.contains('open')) return;

    // Don‚Äôt hijack typing in inputs
    if (e.target && /input|textarea|select|button/i.test(e.target.tagName)) return;
    if (e.target?.isContentEditable) return;

    const k = e.key.toLowerCase();
    if (k === 'd') { setDrawing(!drawingEnabled); e.preventDefault(); }
    else if (k === 'p') { setTool('pen'); e.preventDefault(); }
    else if (k === 'e') { setTool('eraser'); e.preventDefault(); }
    else if (k === 'z' && (e.ctrlKey || e.metaKey)) { strokes.pop(); save(); redraw(); e.preventDefault(); }
  });

  window.addEventListener('resize', fitCanvas, {passive:true});

  // redraw when viewport scrolls
  window.addEventListener('scroll', scheduleRedraw, { passive: true });

  // redraw for nested scrollable containers (capture phase catches them)
  document.addEventListener('scroll', scheduleRedraw, { passive: true, capture: true });

  // stay smooth during touch scrolling
  window.addEventListener('touchmove', scheduleRedraw, { passive: true });

  // handle rotation and tab visibility
  window.addEventListener('orientationchange', scheduleRedraw, { passive: true });
  document.addEventListener('visibilitychange', () => {
    if (!document.hidden) scheduleRedraw();
  }, { passive: true });

    // respond to DPR changes (pinch-zoom)
  if (window.matchMedia) {
    const dppx = Math.round((window.devicePixelRatio || 1) * 10) / 10;
    const mq = matchMedia(`(resolution: ${dppx}dppx)`);
    mq.addEventListener?.('change', () => { fitCanvas(); }); // Safari/iOS
  }

  document.addEventListener('toggle', (e) => {
    if (e.target.tagName?.toLowerCase() === 'details') requestAnimationFrame(scheduleRedraw);
  }, true);
  document.addEventListener('show.bs.collapse', () => scheduleRedraw());
  document.addEventListener('hide.bs.collapse', () => scheduleRedraw());

  // If a details/collapse uses CSS height transitions, redraw after it ends.
  document.addEventListener('transitionend', (e) => {
    const t = e.target;
    if (!t) return;
    // common containers that change height
    if (t.matches?.('details, .collapse, .callout, [data-ink-surface]')) {
        scheduleRedraw();
    }
  }, { passive: true, capture: true });

  // Bootstrap‚Äôs final state events 
  document.addEventListener('shown.bs.collapse',  () => scheduleRedraw());
  document.addEventListener('hidden.bs.collapse', () => scheduleRedraw());


  // --- initialise ---
  load(); fitCanvas();
  setDrawing(false);   // ensures initial visual state is consistent
  setTool('pen');

  const m = new MutationObserver(() => {
    const open = toolbar.classList.contains('open');
    toolbar.setAttribute('aria-hidden', open ? 'false' : 'true');
  });
  m.observe(toolbar, {attributes:true, attributeFilter:['class']});

  // keep canvas sized if the document grows (e.g., lazy images)
  const ro = new ResizeObserver(()=> fitCanvas());
  ro.observe(document.documentElement);
})();
</script>
